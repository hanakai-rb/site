# frozen_string_literal: true

require "hanami/boot"

Parklife.application.configure do |config|
  config.app = Site::App

  # Generate e.g. /nested/route.html instead of /nested/route/index.html. This will see Netlify
  # ensure there are no trailing slashes on URLs, which is consistent with our routing when serving
  # the live Hanami app.
  config.nested_index = false

  # Skip writing 404 responses as static files.
  #
  # For the moment, this allows us to use versionless URLs that we know will redirect in production.
  config.on_404 = :skip
end

Parklife.application.routes do
  root crawl: true

  # Add further paths not discovered by crawling from the root:
  #
  # get '/hidden/pages', crawl: true
  # get '/feed.atom'

  # Services typically allow a custom 404 page.
  # get '/404.html'
end

# Build search index after Parkfile is loaded
# This will run during the build process
at_exit do
  if $!.nil? || $!.is_a?(SystemExit) && $!.success?
    # Only build search index if parklife build was successful
    if defined?(Parklife) && ARGV.include?("build")
      puts "\n==> Building Pagefind search index..."
      require "fileutils"

      puts "Indexing build directory..."
      FileUtils.mkdir_p("build")
      result = system("npx pagefind --site build")

      if result
        # Calculate total size of pagefind directory
        total_size = Dir.glob("build/pagefind/**/*")
          .select { |f| File.file?(f) }
          .sum { |f| File.size(f) }

        size_kb = (total_size / 1024.0).round(2)

        puts "✓ Pagefind index built successfully"
        puts "  - build/pagefind/"
        puts "  - Index size: #{size_kb}KB"
      else
        puts "✗ Failed to build Pagefind index"
        exit 1
      end
    end
  end
end
